// ------------------------------------------DIRECTED GRAPH ADJ MATRIX BFS AND DFS----------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
// --------------------------------------------------- NODE STRUCT--------------------------------------------------
struct node{
  int name;
  int color;
};
typedef struct node Tnode;
// --------------------------------------------------- MATRIX ----------------------------------------------------------
int **matrix;
int n;
int head = -1,tail = -1;
// --------------------------------------------------- FUNCTIONS----------------------------------------------------------
// queue
int isEmpty();
void addQueue(int nodeIndex,int queue[]);
int extractQueue(int queue[]);
void findLink(Tnode *nodes[],int indexNode,int queue[]);
 
char readInput();
int charToIndex(Tnode *nodes[],char choice);
// insert
void insertLink(Tnode *nodes[]);
// remove
void removeLink(Tnode *nodes[]);
// print
void printGraphBFS(Tnode *nodes[],int source);
void printGraphDFS(Tnode *nodes[],int node);
// --------------------------------------------------- IS EMPTY----------------------------------------------------------
int isEmpty(){
  if(head == -1 || head > tail)
    return 1;
  else
    return 0;
}
// --------------------------------------------------- READ INPUT----------------------------------------------------------
char readInput(){
  int name;
  printf("\nInsert node name :");
  scanf("%d",&name);
  fflush(stdin);
  return name;
}
// --------------------------------------------------- INSERT LINK----------------------------------------------------------
void insertLink(Tnode *nodes[]){
  int node1,node2;
  printf("->"); node1 = readInput();
  printf("->"); node2 = readInput();
  matrix[node1][node2] = 1;
}
// ---------------------------------------------------REMOVE LINK---------------------------------------------------------
void removeLink(Tnode *nodes[]){
  int node1,node2;
  printf("->"); node1 = readInput();
  printf("->"); node2 = readInput();
  matrix[node1][node2] = 0;
}
// --------------------------------------------------- ADD QUEUE---------------------------------------------------------
void addQueue(int nodeIndex,int queue[]){
  if(tail == n-1)
    printf("error add\n");
  else{
    if(head == -1)
      head = 0;
    tail = tail+1;
    queue[tail] = nodeIndex;
  }
}
// --------------------------------------------------- EXTRACT QUEUE-------------------------------------------------------
int extractQueue(int queue[]){
  int extract;
  if(head == -1 || head > tail){
    printf("error extract %d %d\n",head,tail);
    exit(1);
  }
  extract = queue[head];
  head = head+1;
  return extract;
}
// --------------------------------------------------- FIND LINK--------------------------------------------------------
void findLink(Tnode *nodes[],int indexNode,int queue[]){
  int i;
  for(i=0;i<n;i++){
    if(matrix[indexNode][i] == 1 && nodes[i]->color == 0){
      nodes[i]->color = 1;
      addQueue(i,queue);
    }
  }
}
// --------------------------------------------------- PRINT GRAPH BFS---------------------------------------------------
// in this version i use integer because is simpler than use pointer
// the result is the same
void printGraphBFS(Tnode *nodes[],int source){
  int nodeIndex,i;
  int queue[n];
  for(i=0;i<n;i++){
    nodes[i]->color = 0;
  }
  nodes[source]->color = 1;
  addQueue(source,queue);
  while(!isEmpty()){
    nodeIndex = extractQueue(queue);
    findLink(nodes,nodeIndex,queue);
    nodes[nodeIndex]->color = 2;
    sleep(1);
    printf("Nodo visitato BLACK %d\n",nodes[nodeIndex]->name);
  }
}
// --------------------------------------------------- PRINT GRAPH DFS-----------------------------------------------------
void printGraphDFS(Tnode *nodes[],int node){
  int j;
  printf("Nodo visitato %d\n",node);
  nodes[node]->color = 1;
  for (j = 0; j < n; j++){
    if(!nodes[j]->color && matrix[node][j] == 1){
      printGraphDFS(nodes,j);
   }
  }
}


// --------------------------------------------------- MAIN----------------------------------------------------------
int main(int argc,char *argv[]){
  int i;
  n = atoi(argv[1]);
  fflush(stdin);
  //--------------------------------------- MATRIX
  matrix = (int**)calloc(n,sizeof(int*));
  for(i=0;i<n;i++){
    matrix[i] = (int*)calloc(n,sizeof(int*));
  }
  // -------------------------------------- NODES
  Tnode *node[n];
  for(i=0;i<n;i++){
    node[i] = (Tnode*)malloc(sizeof(Tnode));
    node[i]->name = i;
  }
  /* now the matrix looks like that
       A B C D ...
     A 0 0 0 0
     B 0 0 0 0
     C 0 0 0 0
     D 0 0 0 0
     .
     .
     .
  */
 // using this makes all the things simpler because the link are already done
  matrix[0][1] = 1;
  matrix[0][3] = 1;
  matrix[1][4] = 1;
  matrix[1][2] = 1;
  matrix[2][1] = 1;
  matrix[2][0] = 1;
  matrix[3][2] = 1;
  matrix[3][4] = 1;
  matrix[4][3] = 1;
  matrix[4][1] = 1;
  matrix[4][0] = 1;
 
  int choice,source;
  do{
    printf("\n1.insert link \n2.remove link \n3.BFS \n4.DFS \n");
    scanf("%d",&choice);
    fflush(stdin);
    switch(choice){
    case 1: // insert new LINK
      insertLink(node);
      break;
    case 2: // remove LINK
      removeLink(node);
      break;
    case 3: // print matrix BFS
      printf("Insert source :");
      scanf("%d",&source);
      printGraphBFS(node,source);
      break;
    case 4: // print matrix DFS
      printf("insert source :");
      scanf("%d",&source);                                                                                                                                                                    
      for(i=0;i<n;i++)
        node[i]->color = 0;
      printGraphDFS(node,source);
      break;
    }
  }while(choice != 5);
  return 0;
  }
//-----------------------------------------NOT DIRECTED GRAPH MATRIX BFS AND DFS VISIT----------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int n;
int **matrix;
//---------------------------------------- STRUCT FOR NODES
struct node{
  int name;
  int color; // 0: white | 1: grey | 2: black
};
typedef struct node Tnode;
int head = -1,tail = -1;
//---------------------------------------- FUNCTIONS
int readInput();
// queue for BFS
void addQueue(int node,int queue[]);
int extractQueue(int queue[]);
int isEmpty();
void verifyAdj(int node,Tnode *nodes[],int queue[]);
// insert
void insertLink();
// remove
void removeLink();
void showMatrix();
// visit
void visitBFS(Tnode *nodes[],int node);
void visitDFS(Tnode *nodes[],int node);
//------------------------------------------------------READ INPUT----------------------------------------------------
int readInput(){
  int node;
  printf("Insert node :");
  scanf("%d",&node);
  return node;
}
//-------------------------------------------------------INSERT-------------------------------------------------------
void insertLink(){
  int node1,node2;
  node1 = readInput();
  node2 = readInput();
  matrix[node1][node2] = 1; 
  matrix[node2][node1] = 1;
}
//-------------------------------------------------------REMOVE-------------------------------------------------------
void removeLink(){
  int node1,node2;
  node1 = readInput();
  node2 = readInput();
  matrix[node1][node2] = 0;
  matrix[node1][node2] = 0;
}
//------------------------------------------------------- SHOW MATRIX-------------------------------------------------------
void showMatrix(){
  int i,j;
  for(i=0;i<n;i++){
    printf("\n");
    for(j=0;j<n;j++){
      printf("%d \t",matrix[i][j]);
    }
  }
}
//------------------------------------------------------- VISIT DFS-------------------------------------------------------
void visitDFS(Tnode *nodes[],int node){
  int j;
  printf("Node visited %d \n",node);
  nodes[node]->color = 1;
  for(j=0;j<n;j++){
    if(!nodes[j]->color && matrix[node][j] ==1){
      visitDFS(nodes,j);
    }
  }
}
//------------------------------------------------------- IS EMPTY-------------------------------------------------------
int isEmpty(){
  if(head == -1 || head > tail)
    return 1;
  else
    return 0;
}
//-------------------------------------------------------ADD QUEUE -------------------------------------------------------
void addQueue(int node,int queue[]){
  if(tail== n-1) 
    exit(1);
  else if(head == -1)
    head = 0;
  tail = tail+1;
  queue[tail] = node;
}
//-------------------------------------------------------EXTRACT QUEUE-------------------------------------------------------
int extractQueue(int queue[]){
  int node;
  if(head ==-1 || head > tail)
    exit(1);
  node = queue[head];
  head = head+1;
  return node;
}
//-------------------------------------------------------VERIFY ADJ-------------------------------------------------------
void verifyAdj(int node,Tnode *nodes[],int queue[]){
  int i;
  for(i=0;i<n;i++){
    if(matrix[node][i] == 1 && nodes[i]->color == 0){
      nodes[i]->color = 1; // now is grey
      addQueue(i,queue);
    }
  }
}
//-------------------------------------------------------VISIT BFS-------------------------------------------------------
void visitBFS(Tnode *nodes[],int source){
  int queue[n];
  int i,node;
  for(i=0;i<n;i++){
    nodes[i]->color = 0; // all white
  }
  nodes[source]->color = 1; // source grey
  addQueue(source,queue);
  while(!isEmpty()){
    node = extractQueue(queue);
    verifyAdj(node,nodes,queue);
    nodes[node]->color = 2; // now is black
    sleep(1);
    printf("Node %d\n",node);
  }
}
//-------------------------------------------------------MAIN-------------------------------------------------------
int main(int argc, char *argv[]){
  if(argc <2){
    printf("Write the number of Edges\n");
    exit(1);
  }
  n = atoi(argv[1]);
  int i;
  Tnode *nodes[n];
  for(i=0;i<n;i++){
    nodes[i] = (Tnode*)malloc(sizeof(Tnode));
    nodes[i]->name = i;
    nodes[i]->color = 0;
  }

  matrix = (int**)calloc(n,sizeof(int*));
  for(i=0;i<n;i++){
    matrix[i] = (int*)calloc(n,sizeof(int*));
  }
  
  matrix[0][1] = 1;
  matrix[0][3] = 1;
  
  matrix[1][4] = 1; 
  matrix[1][2] = 1; 

  matrix[2][1] = 1; 
  matrix[2][0] = 1; 
  
  matrix[3][2] = 1; 
  matrix[3][4] = 1; 
  
  matrix[4][3] = 1; 
   matrix[4][1] = 1; 
  matrix[4][0] = 1; 
  // inverse
  matrix[0][2] = 1;
  matrix[0][4] = 1;

  matrix[2][3] = 1;
  matrix[1][0] = 1;
  matrix[3][0] = 1;

  showMatrix();
  printf("\n DFS \n");
  visitDFS(nodes,4);

  printf("\n BFS \n");
  visitBFS(nodes,2);
  return 0;
}
//------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------GRAPH DIRECTED WITH LIST-------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int num;
//-----------------------------------------------------STRUCT NODE-----------------------------------------------------
struct node{
  int info;
  struct node *pNext;
} node;
typedef struct node *Node;

void makeGrafph(Node graph[]);
void insertLink(Node graph[],Node node,int index);
void print(Node node);

int verify(Node node,int info);

//----------------------------------------------------- MAKE GRAPH-----------------------------------------------------
void makeGraph(Node graph[]){
  Node ptr;
  int i,info;
  for(i=0;i<num;i++){
    printf("insert info : ");
    scanf("%d",&info);
    ptr = calloc(1,sizeof(node));
    ptr->info = info;
    graph[i] = ptr;
  }
}
//----------------------------------------------------- INSERT LINK-----------------------------------------------------
void insertLink(Node graph[],Node node,int index){
  Node ptr;
  int i,info,choice;
  do{
    printf("Insert link to %d :\n",graph[index]->info);
    scanf("%d",&info);
    for(i=0;i<num;i++){
      if(graph[i]->info == info){
        ptr = calloc(1,sizeof(node));
        ptr->info = info;
        node->pNext = ptr;
        node = ptr;
        i = num;
      }
    }
    printf("\n0 -> Keep insert \t 1 -> Quit insert \n");
    scanf("%d",&choice);
  }while(choice != 1);
}
//----------------------------------------------------- VERIFY-----------------------------------------------------
int verify(Node node,int info){
  if(node == NULL)
    return 0;
  else if(node->info == info)
    return 1;
  else
    return verify(node->pNext,info);
}
//----------------------------------------------------- PRINT-----------------------------------------------------
void print(Node node){
  while(node != NULL){
    printf("\t%d ->",node->info);
    node = node->pNext;
  }
  printf("\tNULL");
}
//----------------------------------------------------- MAIN-----------------------------------------------------
int main(int argc,char *argv[]){
  if(argc < 2){
    printf("Insert number of nodes.\n");
    exit(1);
  }
  int i;
  num = atoi(argv[1]);

  Node graph[num];
  for(i=0;i<num;i++)
    graph[i] = calloc(1,sizeof(Node));
  
  makeGraph(graph);

  for(i=0;i<num;i++)
    insertLink(graph,graph[i],i);

  sleep(1);
  for(i=0;i<num;i++){
    printf("\n");
    print(graph[i]);
  }
  return 0;
}
//-----------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------GRAPH NOT DIRECTED WITH LIST---------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int num;
//----------------------------------------------------- STRUCT -----------------------------------------------------
struct node{
  int info;
  struct node *pNext;
} node;
typedef struct node *Node;

void makeGrafph(Node graph[]);
void insertCopyLink(Node graph[],Node nodeA,int infoB);
void insertLink(Node graph[],Node node,int index);
void print(Node node);

//----------------------------------------------------- MAKE GRAPH -----------------------------------------------------
void makeGraph(Node graph[]){
  Node ptr;
  int i,info;
  for(i=0;i<num;i++){
    printf("insert info : ");
    scanf("%d",&info);
    ptr = calloc(1,sizeof(node));
    ptr->info = info;
    graph[i] = ptr;
  }
}
//----------------------------------------------------- INSERT COPY LINK --------------------------------------------------
void insertCopyLink(Node graph[],Node nodeA, int infoB){
  int i;
  Node ptr;
  for(i=0;i<num;i++){
    if(graph[i]->info == infoB){
      ptr = calloc(1,sizeof(node));
      ptr->info = graph[i]->info;
      ptr->pNext = NULL;
      while(nodeA->pNext != NULL)
        nodeA = nodeA->pNext;
      nodeA->pNext = ptr;
      i = num;
    }
  }
}
//----------------------------------------------------- INSERT LINK -----------------------------------------------------
void insertLink(Node graph[],Node node,int index){
  Node ptr,ptr2;
  int i,info,choice;
  do{
    printf("Insert link to %d :\n",graph[index]->info);
    scanf("%d",&info);
    for(i=0;i<num;i++){
      if(graph[i]->info == info){
        ptr = calloc(1,sizeof(node)); 
        ptr->info = graph[i]->info;
        ptr->pNext = NULL;
        while(node->pNext != NULL)
          node = node->pNext;
        node->pNext = ptr;
        insertCopyLink(graph,graph[i],graph[index]->info);
        i = num;
      }
    }
    printf("\n1 -> Keep insert \t 2 -> Quit insert \n");
    scanf("%d",&choice);
  }while(choice != 2);
  
}
//----------------------------------------------------- PRINT -----------------------------------------------------
void print(Node node){
  while(node != NULL){
    printf("\t%d ->",node->info);
    node = node->pNext;
  }
  printf("\tNULL");
}
//----------------------------------------------------- MAIN -----------------------------------------------------
int main(int argc,char *argv[]){
  if(argc < 2){
    printf("Insert number of nodes.\n");
    exit(1);
  }
  int i;
  num = atoi(argv[1]);

  Node graph[num];
  for(i=0;i<num;i++)
    graph[i] = calloc(1,sizeof(Node));
  
  makeGraph(graph);

  for(i=0;i<num;i++)
    insertLink(graph,graph[i],i);

  sleep(1);
  for(i=0;i<num;i++){
    printf("\n");
    print(graph[i]);
  }
  return 0;
}



